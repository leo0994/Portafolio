---
import Header from "../components/Header.astro";
import "../styles/global.css";
import "../styles/themes.css";
import "../styles/interactive-effects.css";
import "../styles/header.css";
import "@fontsource/work-sans/400.css";
import Footer from "../components/Footer.astro";

const { description, title } = Astro.props;
---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link
      rel="icon"
      type="image/png"
      href="/Portafolio/icons/logoplasmaceleste.png"
    />

    <meta name="generator" content={Astro.generator} />
    <title>Leo Portafolio</title>

    <!-- GSAP CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"
    ></script>

    <!-- i18next CDN -->
    <script src="https://unpkg.com/i18next@23.4.6/dist/umd/i18next.js"></script>

    <!-- Typed.js CDN -->
    <script
      src="https://unpkg.com/typed.js@2.1.0/dist/typed.umd.js"
      onload="console.log('‚úÖ Typed.js cargado desde CDN'); window.typedLoaded = true;"
    ></script>

    <!-- Script de temas (debe cargar antes que el body para evitar flash) -->
    <script is:inline>
      // Cargar tema guardado antes de que se renderice la p√°gina
      (function () {
        const savedTheme = localStorage.getItem("portfolio-theme") || "default";
        if (savedTheme !== "default") {
          document.documentElement.setAttribute("data-theme", savedTheme);
        }
      })();
    </script>
  </head>
  <body>
    <!-- Loading Screen con Logo Girando (Sobrepuesto) -->
    <div id="loading-screen" class="loading-screen">
      <img
        src="/Portafolio/icons/LogoPlasmaCeleste.png"
        alt="Loading..."
        class="loading-logo"
      />
    </div>

    <!-- Fondo interactivo con gradiente que sigue al mouse -->
    <div class="mouse-gradient-overlay" id="mouse-gradient"></div>

    <!-- Canvas para part√≠culas -->
    <canvas id="particles-canvas"></canvas>

    <!-- Cursor personalizado -->
    <div id="custom-cursor"></div>

    <!-- SVG Filters para efecto l√≠quido -->
    <svg style="position: absolute; width: 0; height: 0;">
      <defs>
        <filter id="liquid-filter" x="-50%" y="-50%" width="200%" height="200%">
          <feTurbulence
            type="fractalNoise"
            baseFrequency="0.01"
            numOctaves="3"
            result="noise"
          >
            <animate
              attributeName="baseFrequency"
              dur="20s"
              values="0.01;0.03;0.01"
              repeatCount="indefinite"></animate>
          </feTurbulence>
          <feDisplacementMap
            in="SourceGraphic"
            in2="noise"
            scale="8"
            xChannelSelector="R"
            yChannelSelector="G"></feDisplacementMap>
        </filter>

        <filter
          id="liquid-filter-intense"
          x="-50%"
          y="-50%"
          width="200%"
          height="200%"
        >
          <feTurbulence
            type="fractalNoise"
            baseFrequency="0.02"
            numOctaves="4"
            result="noise"
          >
            <animate
              attributeName="baseFrequency"
              dur="10s"
              values="0.02;0.05;0.02"
              repeatCount="indefinite"></animate>
          </feTurbulence>
          <feDisplacementMap
            in="SourceGraphic"
            in2="noise"
            scale="15"
            xChannelSelector="R"
            yChannelSelector="G"></feDisplacementMap>
        </filter>
      </defs>
    </svg>

    <!-- Contenedor para logos fantasmales flotantes -->
    <div id="ghost-logos-container"></div>

    <Header />
    <slot />
    <Footer />
    <div class="h-10"></div>
  </body>

  <script is:inline>
    document.addEventListener("DOMContentLoaded", () => {
      console.log("üöÄ DOM cargado, iniciando i18next...");

      const savedLang = localStorage.getItem("lang");
      const userLang =
        savedLang || (navigator.language.startsWith("en") ? "en" : "es");

      // Cargar traducciones primero
      Promise.all([
        fetch("/Portafolio/locales/es/translation.json").then((r) => r.json()),
        fetch("/Portafolio/locales/en/translation.json").then((r) => r.json()),
      ])
        .then(([esData, enData]) => {
          console.log("‚úÖ Traducciones descargadas");

          // Inicializar i18next con los recursos ya cargados
          return i18next.init({
            lng: userLang,
            debug: true,
            resources: {
              es: { translation: esData },
              en: { translation: enData },
            },
          });
        })
        .then(() => {
          console.log("‚úÖ i18next inicializado con idioma:", i18next.language);
          inicializarSistemaIdiomas();
        })
        .catch((error) => {
          console.error("‚ùå Error:", error);
        });

      function actualizarTextos() {
        console.log("üîÑ Actualizando textos...");
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const clave = el.getAttribute("data-i18n");
          const traduccion = i18next.t(clave);
          if (el.tagName === "INPUT" || el.tagName === "TEXTAREA") {
            el.setAttribute("placeholder", traduccion);
          } else {
            el.innerText = traduccion;
          }
        });
      }

      function actualizarBotonesIdioma() {
        const proximoIdioma = i18next.language === "es" ? "EN" : "ES";
        const btnDesktop = document.getElementById("language-toggle");
        const btnMobile = document.getElementById("language-toggle-mobile");

        if (btnDesktop) btnDesktop.innerText = proximoIdioma;
        if (btnMobile) btnMobile.innerText = proximoIdioma;
        console.log("‚úÖ Botones actualizados:", proximoIdioma);
      }

      function toggleIdioma() {
        const nuevoIdioma = i18next.language === "es" ? "en" : "es";
        console.log(`üîÑ Cambiando idioma a ${nuevoIdioma}`);
        localStorage.setItem("lang", nuevoIdioma);
        i18next.changeLanguage(nuevoIdioma).then(() => {
          actualizarTextos();
          actualizarBotonesIdioma();
          console.log("‚úÖ Idioma cambiado");
          // Disparar evento para actualizar Typed.js
          window.dispatchEvent(new Event("languageChanged"));
        });
      }

      function inicializarSistemaIdiomas() {
        console.log("üöÄ Inicializando sistema de idiomas");
        actualizarTextos();
        actualizarBotonesIdioma();

        const btnDesktop = document.getElementById("language-toggle");
        const btnMobile = document.getElementById("language-toggle-mobile");

        if (btnDesktop) {
          btnDesktop.addEventListener("click", toggleIdioma);
          console.log("‚úÖ Listener agregado a bot√≥n desktop");
        }
        if (btnMobile) {
          btnMobile.addEventListener("click", toggleIdioma);
          console.log("‚úÖ Listener agregado a bot√≥n m√≥vil");
        }
      }

      window.debugLanguage = {
        toggleIdioma,
        actualizarTextos,
        currentLang: () => i18next.language,
      };
    });
  </script>

  <script is:inline>
    // Menu functionality
    document.addEventListener("DOMContentLoaded", () => {
      const menuToggle = document.getElementById("menu-toggle");
      const mobileMenu = document.getElementById("mobile-menu");
      const closeMenu = document.getElementById("close-menu");

      if (!menuToggle || !mobileMenu || !closeMenu) return;

      if (typeof gsap === "undefined") {
        console.error("GSAP no est√° disponible");
        return;
      }

      menuToggle.addEventListener("click", () => {
        mobileMenu.classList.remove("hidden");
        mobileMenu.classList.add("flex");

        gsap.to(mobileMenu, {
          x: "-100%",
          duration: 0.5,
          ease: "power2.out",
        });
      });

      closeMenu.addEventListener("click", () => {
        gsap.to(mobileMenu, {
          x: "100%",
          duration: 0.5,
          ease: "power2.in",
          onComplete: () => {
            mobileMenu.classList.add("hidden");
            mobileMenu.classList.remove("flex");
          },
        });
      });
    });
  </script>

  <script is:inline>
    // Animations and header functionality
    document.addEventListener("DOMContentLoaded", () => {
      const nav = document.getElementById("desktop-nav");
      const navLinks = document.querySelectorAll(".nav-link");
      const header = document.querySelector("header");

      if (typeof gsap === "undefined") {
        console.error("GSAP no est√° disponible para animaciones");
        return;
      }

      // Crear underline para animaciones
      if (nav && navLinks.length > 0) {
        const underline = document.createElement("div");
        underline.classList.add("underline-effect");
        nav.appendChild(underline);

        nav.style.position = "relative";

        gsap.set(underline, { width: "0px", opacity: 0, scaleX: 0.5 });

        navLinks.forEach((link) => {
          link.addEventListener("mouseenter", (event) => {
            const linkRect = link.getBoundingClientRect();
            const navRect = nav.getBoundingClientRect();

            gsap.to(underline, {
              width: linkRect.width + "px",
              height: "3px",
              left: linkRect.left - navRect.left + "px",
              top: linkRect.bottom - navRect.top - 2 + "px",
              opacity: 1,
              background:
                "linear-gradient(90deg, rgb(0, 81, 107), rgb(255, 255, 255), rgb(0, 81, 107))",
              boxShadow: "0 0 10px rgb(15, 94, 173)",
              scaleX: 1.3,
              duration: 0.3,
              ease: "power3.out",
            });
          });

          link.addEventListener("mouseleave", () => {
            gsap.to(underline, {
              width: "0px",
              opacity: 0,
              scaleX: 0.5,
              duration: 0.3,
              ease: "power3.in",
            });
          });
        });
      }

      // Actualizar --anchor-offset seg√∫n la altura del header
      function setAnchorOffset() {
        const h = header ? header.getBoundingClientRect().height : 80;
        const extra = 0;
        document.documentElement.style.setProperty(
          "--anchor-offset",
          `${h + extra}px`
        );
      }

      setAnchorOffset();
      window.addEventListener("resize", setAnchorOffset);

      if (header && "ResizeObserver" in window) {
        const ro = new ResizeObserver(() => setAnchorOffset());
        ro.observe(header);
      }
    });
  </script>

  <script is:inline>
    // Typed.js initialization
    (function () {
      let typedInstance = null;
      let retryCount = 0;
      const maxRetries = 10;

      function initTyped() {
        console.log(
          "üöÄ Intentando inicializar Typed.js... (intento " +
            (retryCount + 1) +
            ")"
        );
        console.log("Typed disponible?", typeof Typed);

        const typedElement = document.getElementById("typed-text");

        if (!typedElement) {
          console.error("‚ùå Elemento #typed-text no encontrado");
          return;
        }

        console.log("‚úÖ Elemento encontrado:", typedElement);

        if (typeof Typed === "undefined") {
          retryCount++;
          if (retryCount < maxRetries) {
            console.warn(
              "‚è≥ Typed.js no est√° cargado. Reintentando en 300ms... (intento " +
                retryCount +
                "/" +
                maxRetries +
                ")"
            );
            setTimeout(initTyped, 300);
          } else {
            console.error(
              "‚ùå Typed.js no se pudo cargar despu√©s de " +
                maxRetries +
                " intentos"
            );
          }
          return;
        }

        console.log("‚úÖ Typed.js est√° disponible!");
        retryCount = 0; // Reset counter

        // Destruir instancia anterior si existe
        if (typedInstance) {
          typedInstance.destroy();
          console.log("üóëÔ∏è Instancia anterior destruida");
        }

        // Limpiar cualquier contenido previo
        typedElement.textContent = "";

        // Obtener las strings traducidas
        const currentLang = localStorage.getItem("lang") || "es";
        let strings = [
          "Desarrollador Full Stack",
          "Ingeniero de Software",
          "Desarrollador Web",
          "Arquitecto de Soluciones",
        ];

        if (currentLang === "en") {
          strings = [
            "Full Stack Developer",
            "Software Engineer",
            "Web Developer",
            "Solutions Architect",
          ];
        }

        console.log("üìù Strings a usar:", strings);
        console.log("üåê Idioma actual:", currentLang);

        // Inicializar Typed.js
        try {
          typedInstance = new Typed("#typed-text", {
            strings: strings,
            typeSpeed: 50,
            backSpeed: 30,
            backDelay: 2000,
            loop: true,
            showCursor: true,
            cursorChar: "|",
          });

          console.log("‚úÖ Typed.js inicializado correctamente!", typedInstance);
        } catch (error) {
          console.error("‚ùå Error al inicializar Typed.js:", error);
        }
      }

      // Funci√≥n para reiniciar con cambio de idioma
      window.restartTyped = function () {
        console.log("üîÑ Reiniciando Typed.js...");
        if (typedInstance) {
          typedInstance.destroy();
          typedInstance = null;
        }
        setTimeout(initTyped, 100);
      };

      // Inicializar cuando el DOM est√© listo
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          console.log("üìÑ DOM cargado");
          setTimeout(initTyped, 1500);
        });
      } else {
        console.log("üìÑ DOM ya estaba cargado");
        setTimeout(initTyped, 1500);
      }

      // Reinicializar cuando cambie el idioma
      window.addEventListener("languageChanged", function () {
        console.log("üîÑ Evento languageChanged recibido");
        window.restartTyped();
      });
    })();
  </script>

  <script is:inline>
    // Sistema de gesti√≥n de temas
    (function () {
      const THEME_KEY = "portfolio-theme";
      const DEFAULT_THEME = "default";

      function setTheme(themeName) {
        console.log("üé® Cambiando a tema:", themeName);

        // Remover el atributo si es el tema por defecto
        if (themeName === DEFAULT_THEME) {
          document.documentElement.removeAttribute("data-theme");
        } else {
          document.documentElement.setAttribute("data-theme", themeName);
        }

        // Guardar en localStorage
        localStorage.setItem(THEME_KEY, themeName);

        // Actualizar botones activos
        updateThemeButtons(themeName);

        console.log("‚úÖ Tema aplicado:", themeName);
      }

      function updateThemeButtons(activeTheme) {
        const buttons = document.querySelectorAll("[data-theme-btn]");
        buttons.forEach((btn) => {
          const themeName = btn.getAttribute("data-theme-btn");
          const indicator = btn.querySelector(".w-3.h-3");

          if (themeName === activeTheme) {
            // Bot√≥n activo
            btn.classList.add(
              "ring-2",
              "ring-white",
              "ring-offset-2",
              "ring-offset-black/90"
            );
            btn.style.transform = "scale(1.05)";

            // Indicador animado
            if (indicator) {
              indicator.style.animation =
                "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite";
              indicator.style.boxShadow = "0 0 10px currentColor";
            }
          } else {
            // Bot√≥n inactivo
            btn.classList.remove(
              "ring-2",
              "ring-white",
              "ring-offset-2",
              "ring-offset-black/90"
            );
            btn.style.transform = "scale(1)";

            if (indicator) {
              indicator.style.animation = "";
              indicator.style.boxShadow = "none";
            }
          }
        });
      }

      function initThemeSystem() {
        console.log("üöÄ Inicializando sistema de temas");

        // Obtener tema guardado
        const savedTheme = localStorage.getItem(THEME_KEY) || DEFAULT_THEME;
        console.log("üìå Tema guardado en localStorage:", savedTheme);

        // Verificar atributo actual
        const currentTheme =
          document.documentElement.getAttribute("data-theme");
        console.log("üìå Tema actual en HTML:", currentTheme || "default");

        // Aplicar tema inicial (ya se aplic√≥ en el head, solo actualizamos botones)
        updateThemeButtons(savedTheme);

        // Agregar event listeners a los botones
        const buttons = document.querySelectorAll("[data-theme-btn]");
        console.log("üìå Botones de tema encontrados:", buttons.length);

        buttons.forEach((btn) => {
          btn.addEventListener("click", function () {
            const themeName = this.getAttribute("data-theme-btn");
            console.log("üëÜ Click en bot√≥n de tema:", themeName);
            setTheme(themeName);
          });
        });

        console.log("‚úÖ Sistema de temas inicializado con tema:", savedTheme);
      }

      // Inicializar cuando el DOM est√© listo
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initThemeSystem);
      } else {
        initThemeSystem();
      }

      // Exponer funci√≥n global para cambiar tema manualmente
      window.setPortfolioTheme = setTheme;
    })();
  </script>

  <script is:inline>
    // Efectos interactivos del mouse
    (function () {
      let mouseX = 0;
      let mouseY = 0;
      const ripples = [];

      // Cursor personalizado
      const cursor = document.getElementById("custom-cursor");
      const gradient = document.getElementById("mouse-gradient");
      const canvas = document.getElementById("particles-canvas");

      if (!canvas) return;

      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Resize canvas
      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      // Seguir mouse - Cursor personalizado
      document.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        if (cursor) {
          cursor.style.left = mouseX + "px";
          cursor.style.top = mouseY + "px";
        }

        // Actualizar gradiente que sigue al mouse
        if (gradient) {
          const xPercent = (mouseX / window.innerWidth) * 100;
          const yPercent = (mouseY / window.innerHeight) * 100;
          gradient.style.setProperty("--mouse-x", xPercent + "%");
          gradient.style.setProperty("--mouse-y", yPercent + "%");
        }
      });

      // Efecto moderno al hacer click - Ondas expansivas
      document.addEventListener("click", (e) => {
        if (cursor) {
          cursor.classList.add("clicked");
          setTimeout(() => cursor.classList.remove("clicked"), 200);
        }

        // Crear ondas ripple modernas
        createRipple(e.clientX, e.clientY);
      });

      // Sistema de ondas ripple moderno
      class Ripple {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 0;
          this.maxRadius = 120;
          this.opacity = 1;
          this.growthSpeed = 4;
          this.lineWidth = 3;

          // Obtener colores del tema actual
          const styles = getComputedStyle(document.documentElement);
          const accentPrimary =
            styles.getPropertyValue("--accent-primary").trim() || "#3b82f6";
          const accentSecondary =
            styles.getPropertyValue("--accent-secondary").trim() || "#60a5fa";

          // Crear gradiente para el ripple
          this.gradient = ctx.createRadialGradient(
            x,
            y,
            0,
            x,
            y,
            this.maxRadius
          );
          this.gradient.addColorStop(0, accentPrimary);
          this.gradient.addColorStop(0.5, accentSecondary);
          this.gradient.addColorStop(1, accentPrimary);
        }

        update() {
          this.radius += this.growthSpeed;
          this.opacity = 1 - this.radius / this.maxRadius;
          this.lineWidth = 3 * this.opacity;
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.opacity;

          // Dibujar onda circular principal
          ctx.strokeStyle = this.gradient;
          ctx.lineWidth = this.lineWidth;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.stroke();

          // Dibujar onda secundaria (m√°s peque√±a, dentro)
          if (this.radius > 20) {
            ctx.globalAlpha = this.opacity * 0.5;
            ctx.lineWidth = this.lineWidth * 0.7;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
          }

          // Dibujar glow central
          if (this.radius < 30) {
            const glowGradient = ctx.createRadialGradient(
              this.x,
              this.y,
              0,
              this.x,
              this.y,
              30
            );
            glowGradient.addColorStop(
              0,
              `rgba(59, 130, 246, ${this.opacity * 0.8})`
            );
            glowGradient.addColorStop(1, "rgba(59, 130, 246, 0)");

            ctx.globalAlpha = this.opacity;
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        isDead() {
          return this.radius >= this.maxRadius;
        }
      }

      function createRipple(x, y) {
        ripples.push(new Ripple(x, y));

        // Crear part√≠culas flotantes elegantes alrededor del click
        createFloatingParticles(x, y);
      }

      // Part√≠culas flotantes elegantes (complemento al ripple)
      class FloatingParticle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 3 + 1;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 2 + 1;
          this.speedX = Math.cos(angle) * speed;
          this.speedY = Math.sin(angle) * speed - 2;
          this.life = 1;
          this.decay = Math.random() * 0.015 + 0.01;

          const styles = getComputedStyle(document.documentElement);
          const accentPrimary =
            styles.getPropertyValue("--accent-primary").trim() || "#3b82f6";
          this.color = accentPrimary;
        }

        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.speedX *= 0.98;
          this.speedY += 0.1;
          this.life -= this.decay;
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.life;

          // Dibujar con glow
          const glowGradient = ctx.createRadialGradient(
            this.x,
            this.y,
            0,
            this.x,
            this.y,
            this.size * 2
          );
          glowGradient.addColorStop(0, this.color);
          glowGradient.addColorStop(1, "rgba(59, 130, 246, 0)");

          ctx.fillStyle = glowGradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        isDead() {
          return this.life <= 0;
        }
      }

      const floatingParticles = [];

      function createFloatingParticles(x, y) {
        const particleCount = 8;
        for (let i = 0; i < particleCount; i++) {
          floatingParticles.push(new FloatingParticle(x, y));
        }
      }

      function animateEffects() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Animar ripples
        for (let i = ripples.length - 1; i >= 0; i--) {
          ripples[i].update();
          ripples[i].draw();

          if (ripples[i].isDead()) {
            ripples.splice(i, 1);
          }
        }

        // Animar part√≠culas flotantes
        for (let i = floatingParticles.length - 1; i >= 0; i--) {
          floatingParticles[i].update();
          floatingParticles[i].draw();

          if (floatingParticles[i].isDead()) {
            floatingParticles.splice(i, 1);
          }
        }

        requestAnimationFrame(animateEffects);
      }

      animateEffects();

      console.log("‚ú® Efectos interactivos modernos activados");
    })();
  </script>

  <!-- Script de efecto de texto Scramble (estilo Digimon) -->
  <script is:inline>
    // @ts-nocheck
    (function () {
      console.log("üî§ Inicializando efecto de texto scramble estilo Digimon");

      // Caracteres aleatorios para el efecto (s√≠mbolos, letras, n√∫meros)
      const chars =
        "!<>-_\\/[]{}‚Äî=+*^?#________ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$%&";

      class TextScramble {
        constructor(el) {
          this.el = el;
          this.chars = chars;
          this.update = this.update.bind(this);
        }

        setText(newText) {
          const oldText = this.el.innerText;
          const length = Math.max(oldText.length, newText.length);
          const promise = new Promise((resolve) => (this.resolve = resolve));
          this.queue = [];
          for (let i = 0; i < length; i++) {
            const from = oldText[i] || "";
            const to = newText[i] || "";
            const start = Math.floor(Math.random() * 40);
            const end = start + Math.floor(Math.random() * 40);
            this.queue.push({ from, to, start, end });
          }
          cancelAnimationFrame(this.frameRequest);
          this.frame = 0;
          this.update();
          return promise;
        }

        update() {
          let output = "";
          let complete = 0;
          for (let i = 0, n = this.queue.length; i < n; i++) {
            let { from, to, start, end, char } = this.queue[i];
            if (this.frame >= end) {
              complete++;
              output += to;
            } else if (this.frame >= start) {
              if (!char || Math.random() < 0.28) {
                char = this.randomChar();
                this.queue[i].char = char;
              }
              output += `<span class="scramble-char">${char}</span>`;
            } else {
              output += from;
            }
          }
          this.el.innerHTML = output;
          if (complete === this.queue.length) {
            this.resolve();
          } else {
            this.frameRequest = requestAnimationFrame(this.update);
            this.frame++;
          }
        }

        randomChar() {
          return this.chars[Math.floor(Math.random() * this.chars.length)];
        }
      }

      // Funci√≥n para aplicar efecto scramble a un elemento
      function applyScrambleEffect(element, delay = 0) {
        const originalText =
          element.getAttribute("data-text") || element.innerText;
        if (!element.getAttribute("data-text")) {
          element.setAttribute("data-text", originalText);
        }

        const fx = new TextScramble(element);

        setTimeout(() => {
          // Primero mostrar s√≠mbolos aleatorios
          const randomText = Array(originalText.length)
            .fill(0)
            .map(() => chars[Math.floor(Math.random() * chars.length)])
            .join("");

          element.innerText = randomText;

          // Luego revelar el texto real
          setTimeout(() => {
            fx.setText(originalText);
          }, 100);
        }, delay);
      }

      // Elementos a los que NO aplicar el efecto (inputs, botones peque√±os, etc)
      const excludeSelectors = [
        "input",
        "textarea",
        "button:not(.nav-link):not([data-scramble])",
        "select",
        ".no-scramble",
        "script",
        "style",
        "svg",
        "path",
        "#typed-text", // Excluir el elemento de Typed.js
        ".typed-cursor", // Excluir el cursor de Typed.js
      ];

      // Funci√≥n para verificar si un elemento debe ser excluido
      function shouldExclude(element) {
        // Excluir si tiene el id typed-text o es hijo de un elemento con typed
        if (element.id === "typed-text" || element.closest("#typed-text")) {
          return true;
        }

        // Excluir si tiene clase no-scramble o est√° dentro de un elemento con esa clase
        if (
          element.classList.contains("no-scramble") ||
          element.closest(".no-scramble")
        ) {
          return true;
        }

        // Excluir si tiene atributo data-typed o clase typed-cursor
        if (
          element.hasAttribute("data-typed") ||
          element.classList.contains("typed-cursor")
        ) {
          return true;
        }

        // Excluir si es un elemento de la lista
        for (const selector of excludeSelectors) {
          if (element.matches(selector)) return true;
        }

        // Excluir si est√° dentro de un elemento excluido
        for (const selector of excludeSelectors) {
          if (element.closest(selector)) return true;
        }

        // Excluir textos muy cortos (menos de 2 caracteres)
        const text = element.innerText?.trim();
        if (!text || text.length < 2) return true;

        return false;
      }

      // Aplicar efecto a todos los elementos de texto visibles
      function scrambleAllText() {
        // Selectores principales de texto (incluyendo nav links del header)
        const textSelectors = [
          "h1:not(.no-scramble)",
          "h2:not(.no-scramble)",
          "h3:not(.no-scramble)",
          "h4:not(.no-scramble)",
          "h5:not(.no-scramble)",
          "h6:not(.no-scramble)",
          "p:not(.no-scramble)",
          "a.nav-link", // Links de navegaci√≥n
          "header a", // Todos los enlaces del header
          "#language-toggle", // Bot√≥n de idioma desktop
          "#language-toggle-mobile", // Bot√≥n de idioma m√≥vil
          "button[id^='language-toggle']", // Cualquier bot√≥n de idioma
          "span:not(.scramble-char):not(.no-scramble):not(#typed-text):not(.typed-cursor)",
          ".text-scramble",
          "[data-scramble]",
        ];

        let delay = 0; // Empezar sin delay para que todo se anime simult√°neamente

        textSelectors.forEach((selector) => {
          const elements = document.querySelectorAll(selector);
          elements.forEach((element) => {
            // Solo aplicar a elementos que tienen texto directo (no hijos)
            const hasTextContent = Array.from(element.childNodes).some(
              (node) =>
                node.nodeType === Node.TEXT_NODE && node.textContent.trim()
            );

            if (!shouldExclude(element) && element.offsetParent !== null) {
              applyScrambleEffect(element, delay);
              delay += 20; // Delay muy corto para efecto casi simult√°neo
            }
          });
        });
      }

      // Variable para controlar si ya se ejecut√≥ el efecto inicial
      let initialScrambleDone = false;

      // Ejecutar cuando el loading screen desaparece
      window.addEventListener("loadingComplete", () => {
        if (!initialScrambleDone) {
          setTimeout(scrambleAllText, 100);
          initialScrambleDone = true;
        }
      });

      // Re-aplicar cuando cambia el idioma
      window.addEventListener("languageChanged", () => {
        setTimeout(scrambleAllText, 200);
      });

      console.log("‚úÖ Efecto scramble estilo Digimon activado");
    })();
  </script>

  <!-- Script de Logos Fantasmales Flotantes -->
  <script>
    (function () {
      console.log("üëª Inicializando sistema de logos fantasmales");

      const container = document.getElementById("ghost-logos-container");
      const logoSrc = "/Portafolio/icons/LogoPlasmaCeleste.png";

      // Configuraci√≥n
      const config = {
        initialDelay: 2000,
        fadeInOutInterval: 3000,
        maxLogos: 1, // Solo 1 logo
      };

      let activeLogos = 0;

      class GhostLogo {
        element: HTMLImageElement;
        targetOpacity: number;
        pulseInterval: number | undefined;

        constructor() {
          this.element = document.createElement("img");
          this.element.src = logoSrc;
          this.element.className = "ghost-logo";

          const size = 150;
          this.element.style.width = `${size}px`;
          this.element.style.height = `${size}px`;

          // Mayor opacidad para mejor visibilidad
          this.targetOpacity = 0.6;
          this.element.style.opacity = "0";
          this.element.style.transition = "opacity 2.5s ease-in-out";

          // Posici√≥n inicial - centro derecha
          this.element.style.position = "fixed";
          this.element.style.left = "0";
          this.element.style.top = "0";
          this.element.style.zIndex = "10";

          // Animaci√≥n elegante: movimiento por toda la pantalla + giro constante
          this.element.style.animation =
            "ghost-elegant-float 25s ease-in-out infinite, ghost-spin-continuous 4s linear infinite";

          if (container) {
            container.appendChild(this.element);
          }
          activeLogos++;

          // Fade in inicial m√°s suave
          setTimeout(() => {
            this.element.style.opacity = String(this.targetOpacity);
          }, 200);

          // Pulsar: desvanece y aparece continuamente
          this.startPulsing();
        }

        startPulsing() {
          this.pulseInterval = setInterval(() => {
            // Fade out suave
            this.element.style.opacity = "0.2";

            setTimeout(() => {
              // Fade in suave
              this.element.style.opacity = String(this.targetOpacity);
            }, 2000);
          }, 6000); // Pulsa cada 6 segundos
        }

        destroy() {
          if (this.pulseInterval) {
            clearInterval(this.pulseInterval);
          }
          if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
            activeLogos--;
          }
        }
      }

      // Crear un √∫nico logo permanente
      setTimeout(() => {
        if (activeLogos < config.maxLogos) {
          new GhostLogo();
          console.log("üëª Logo fantasmal √∫nico creado");
        }
      }, config.initialDelay);

      console.log("‚úÖ Sistema de logos fantasmales activado");
    })();
  </script>

  <!-- Script de Scroll Reveal para componentes -->
  <script is:inline>
    // @ts-nocheck
    (function () {
      console.log("üìú Inicializando efecto Scroll Reveal");

      // Configurar Intersection Observer para revelar elementos
      const observerOptions = {
        root: null,
        rootMargin: "0px",
        threshold: 0.1, // 10% del elemento visible
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("reveal-visible");
            // Opcional: dejar de observar despu√©s de revelar
            // observer.unobserve(entry.target);
          }
        });
      }, observerOptions);

      // Esperar a que el DOM est√© listo
      function initScrollReveal() {
        // Seleccionar elementos a revelar
        const revealElements = document.querySelectorAll(
          "section, .experience-item, article, .project-card, h1, h2, h3"
        );

        revealElements.forEach((el, index) => {
          // A√±adir clase inicial para ocultar
          el.classList.add("reveal-hidden");

          // Peque√±o delay escalonado para efecto en cascada
          el.style.transitionDelay = `${index * 0.05}s`;

          // Observar el elemento
          observer.observe(el);
        });

        console.log(
          `‚úÖ ${revealElements.length} elementos configurados para reveal`
        );
      }

      // Inicializar cuando cargue el DOM
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initScrollReveal);
      } else {
        initScrollReveal();
      }
    })();
  </script>

  <!-- Script de Loading Screen -->
  <script>
    (function () {
      const loadingScreen = document.getElementById("loading-screen");

      // Activar scramble inmediatamente (concurrentemente con el logo)
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
          window.dispatchEvent(new Event("loadingComplete"));
        });
      } else {
        // Si ya est√° cargado, activar inmediatamente
        setTimeout(() => {
          window.dispatchEvent(new Event("loadingComplete"));
        }, 100);
      }

      // Desaparecer el logo despu√©s de 1.8 segundos
      setTimeout(() => {
        if (loadingScreen) {
          loadingScreen.style.opacity = "0";

          setTimeout(() => {
            if (loadingScreen) {
              loadingScreen.style.display = "none";
            }
          }, 600); // Duraci√≥n del fade out
        }
      }, 1800); // Logo visible por 1.8 segundos
    })();
  </script>

  <style>
    /* Contenedor de logos fantasmales */
    #ghost-logos-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 0;
      overflow: visible;
    }

    /* Logo fantasmal flotante */
    .ghost-logo {
      pointer-events: none;
      opacity: 0;
      transform: scale(0.8);
      transition:
        opacity 2.5s ease-in-out,
        transform 2.5s ease-in-out;
      filter: blur(0.5px);
      will-change: transform, opacity;
    }

    /* Scroll Reveal - Estados inicial y visible */
    .reveal-hidden {
      opacity: 0;
      transform: translateY(50px);
      transition:
        opacity 0.6s ease-out,
        transform 0.6s ease-out;
    }

    .reveal-visible {
      opacity: 1;
      transform: translateY(0);
    }

    @keyframes ghost-spin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    /* Giro r√°pido para el logo fantasma */
    @keyframes ghost-spin-fast {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    /* Flotaci√≥n amplia por toda la pantalla */
    @keyframes ghost-float-wide {
      0%,
      100% {
        transform: translate(0, 0);
      }
      25% {
        transform: translate(-150px, -100px);
      }
      50% {
        transform: translate(120px, -80px);
      }
      75% {
        transform: translate(-80px, 60px);
      }
    }

    /* Flotaci√≥n sutil para logo fantasma */
    @keyframes ghost-float-subtle {
      0%,
      100% {
        transform: translate(0, 0);
      }
      25% {
        transform: translate(-30px, -20px);
      }
      50% {
        transform: translate(20px, -25px);
      }
      75% {
        transform: translate(-25px, 15px);
      }
    }

    /* Animaci√≥n elegante: movimiento fluido por toda la pantalla */
    @keyframes ghost-elegant-float {
      0% {
        left: calc(100% - 200px);
        top: 50%;
      }
      12.5% {
        left: calc(100% - 150px);
        top: 20%;
      }
      25% {
        left: 50%;
        top: 10%;
      }
      37.5% {
        left: 15%;
        top: 25%;
      }
      50% {
        left: 10%;
        top: 60%;
      }
      62.5% {
        left: 20%;
        top: calc(100% - 200px);
      }
      75% {
        left: 60%;
        top: calc(100% - 150px);
      }
      87.5% {
        left: calc(100% - 180px);
        top: calc(100% - 200px);
      }
      100% {
        left: calc(100% - 200px);
        top: 50%;
      }
    }

    /* Giro continuo e independiente */
    @keyframes ghost-spin-continuous {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    /* Animaci√≥n combinada: rotaci√≥n + flotaci√≥n */
    @keyframes ghost-rotate-float {
      0% {
        transform: translate(0, 0) rotate(0deg);
      }
      25% {
        transform: translate(-20px, -15px) rotate(90deg);
      }
      50% {
        transform: translate(15px, -20px) rotate(180deg);
      }
      75% {
        transform: translate(-15px, 10px) rotate(270deg);
      }
      100% {
        transform: translate(0, 0) rotate(360deg);
      }
    }

    @keyframes ghost-float {
      0%,
      100% {
        transform: translate(0, 0);
      }
      25% {
        transform: translate(20px, -30px);
      }
      50% {
        transform: translate(-15px, 20px);
      }
      75% {
        transform: translate(25px, -15px);
      }
    }

    @keyframes ghost-move {
      0%,
      100% {
        transform: translate(0, 0) rotate(0deg);
      }
      25% {
        transform: translate(40px, -25px) rotate(90deg);
      }
      50% {
        transform: translate(-30px, 35px) rotate(180deg);
      }
      75% {
        transform: translate(35px, -20px) rotate(270deg);
      }
    }

    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: transparent;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.6s ease-out;
      pointer-events: none;
    }

    .loading-logo {
      width: 180px;
      height: 180px;
      object-fit: contain;
      animation: spin-logo-loading 2.5s ease-in-out infinite;
    }

    @keyframes spin-logo-loading {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    /* Efecto Scramble */
    .scramble-char {
      color: var(--accent-primary, #ff00b6);
      opacity: 0.8;
      font-weight: bold;
      animation: scramble-glow 0.3s ease-in-out;
    }

    @keyframes scramble-glow {
      0%,
      100% {
        opacity: 0.6;
      }
      50% {
        opacity: 1;
        text-shadow: 0 0 8px var(--accent-primary, #ff00b6);
      }
    }
  </style>
</html>
